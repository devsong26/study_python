"""
    Better way 5: 시퀀스를 슬라이스하는 방법을 알자

    파이썬은 시퀀스를 슬라이스하는 방법을 제공.
    슬라이스하면 최소한의 노력으로 시퀀스 아이템의 부분집합에 접근 가능
    가장 간단한 슬라이싱 대상은 내장 타입인 List, str, bytes이다.
    __getitem__과 __setitem__이라는 특별한 메서드를 구현하는 파이썬의
    클래스에도 슬라이싱을 적용할 수 있다.
    (Better way 28 "커스텀 컨테이너 타입은 collection.abc의 클래스를
    상속받게 만들자" 참고)

    슬라이싱 문법의 기본 형태는 somelist[start:end]이며, 여기서 start 인덱스는
    포함되고 end 인덱스는 제외된다.
"""
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('First four:', a[:4])
print('Last four:', a[-4:])
print('Middle two:', a[3:-3])

assert a[:5] == a[0:5]
assert a[5:] == a[5:len(a)]

a[:]        # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5]       # ['a', 'b', 'c', 'd', 'e']
a[:-1]      # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:]       #                     ['e', 'f', 'g', 'h']
a[-3:]      #                          ['f', 'g', 'h']
a[2:5]      #           ['c', 'd', 'e']
a[2:-1]     #           ['c', 'd', 'e', 'f', 'g']
a[-3:-1]    #                          ['f', 'g']
"""
    슬라이싱은 start와 end 인덱스가 리스트의 경계를 벗어나도 적절하게 처리한다.
    덕분에 입력 시퀀스에 대응해 처리할 최대 길이를 코드로 쉽게 설정 가능
"""
first_twenty_items = a[:20]
last_twenty_items = a[-20:]

"""
    이와 대조로 같은 인덱스를 직접 접근하면 예외가 발생
"""
try:
    a[20]
except IndexError:
    print("인덱스가 범위를 벗어남")
"""
    리스트의 인덱스를 음수 변수로 지정하면 슬라이싱으로 뜻밖의 결과를 얻는
    몇 가지 상황 중 하나가 발생하니 주의해야 한다.
    예를 들어 somelist[-n:]이라는 구문은 somelist[-3:0]처럼 n이 1보다
    클 때는 제대로 동작한다. 그러나 n이 0이어서 somelist[-0:]이 되면 원본
    리스트의 복사본을 만든다.
    
    슬라이싱의 결과는 완전히 새로운 리스트다. 물론 원본 리스트에 들어 있는 
    객체에 대한 참조는 유지된다. 하지만 슬라이스한 결과를 수정해도 원본 리스트에 
    아무런 영향을 미치지 않는다.
"""
b = a[4:]
print('Before:  ', b)
b[1] = 99
print('After:   ', b)
print('No change:', a)

"""
    할당에 사용하면 슬라이스는 원본 리스트에서 지정한 범위를 대체한다. 
    a, b = c[:2] 같은 튜플 할당과 달리 슬라이스 할당의 길이는 달라도 된다.
    할당받은 슬라이스의 앞뒤 값은 유지된다. 리스트는 새로 들어온 값에 맞춰 늘어나거나
    줄어든다.
"""
print('Before ', a)
a[2:7] = [99, 22, 14]
print('After ', a)

"""
    시작과 끝 인덱스를 모두 생략하고 슬라이스하면 원본 리스트의 복사본을 얻음
"""
b = a[:]
assert b == a and b is not a
"""
    슬라이스에 시작과 끝 인덱스를 지정하지 않고 할당하면 (새 리스트를 할당하지 않고)
    슬라이스의 전체 내용을 참조 대상의 복사본으로 대체한다.
"""
b = a
print('Before', a)
a[:] = [101, 102, 103]
assert a is b               # 여전히 같은 리스트 객체임
print('After ', a)          # 이제 다른 내용을 담음
