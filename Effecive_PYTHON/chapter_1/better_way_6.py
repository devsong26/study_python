"""
    Better way 6: 한 슬라이스에 start, end, stride를 함께 쓰지 말자

    슬라이스의 스트라이드(간격)을 설정하는 특별한 문법이 있다.
    이 문법을 이용하면 시퀀스를 슬라이스할 때 매 n번째 아이템을 가져올 수 있다.
"""
a = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
evens = a[::2]
odds = a[1::2]
print(odds)
print(evens)

"""
    문제는 stride 문법이 종종 예상치 못한 동작을 해서 버그를 만들어내기도 
    한다는 점이다. 예를 들어 파이썬에서 바이트 문자열을 역순으로 만드는 일반적인 
    방법은 스트라이드 -1로 문자열을 슬라이스하는 것이다.
"""
x = b'mongoose'
y = x[::-1]
print(y)
"""
    바이트 문자열, 아스키 문자에는 잘 적용되지만 UTF-8 바이트 문자열로 인코드된
    유니코드 문자에는 원하는 대로 동작하지 않는다.
"""
w = '謝謝'
x = w.encode('utf-8')
y = x[::-1]
try:
    z = y.decode('utf-8')
except UnicodeDecodeError:
    print("utf-8에서는 stride -1로 사용하는 역순이 사용 안됨")

a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[::2]      # ['a', 'c', 'e', 'g']
a[::-2]     # ['h', 'f', 'd', 'b']
"""
    start, end, stride가 같이 사용되면 가독성이 떨어진다.
    stride를 사용해야 한다면 양수 값을 사용하고 start와 end 인덱스는 
    생략하는 게 좋다.
    stride를 반드시 start, end와 같이 사용해야 한다면 stride를 적용한 결과를
    변수에 할당하고, 이 변수를 슬라이스한 결과를 다른 변수에 할당해서 사용하자.
"""
b = a[::2]      # ['a', 'c', 'e', 'g']
c = b[1:-1]     # ['c', 'e']

"""
    슬라이싱부터 하고 스트라이딩을 하면 데이터의 얕은 복사본이 추가로 생긴다.
    첫 번째 연산은 결과로 나오는 슬라이스의 크기를 최대한 줄여야 한다.
    프로그램에서 두 과정에 필요한 시간과 메모리가 충분하지 않다면 내장 모듈
    itertools의 islice 메서드(Better way 46 "내장 알고리즘과 자료 구조를
    사용하자" 참고)를 사용해보자. 
    islice 메서드는 start, end, stride에 음수 값을 허용하지 않는다.
"""